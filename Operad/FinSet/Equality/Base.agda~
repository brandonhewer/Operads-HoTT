{-# OPTIONS --cubical --no-import-sorts --safe #-}

module Operad.FinSet.Equality.Base where

open import Cubical.Data.Empty renaming (rec to ⊥-rec)
open import Cubical.Data.Sigma

open import Cubical.Foundations.Equiv
open import Cubical.Foundations.Function
open import Cubical.Foundations.Isomorphism
open import Cubical.Foundations.Prelude
open import Cubical.Foundations.Univalence

open import Cubical.Functions.Embedding

open import Cubical.HITs.PropositionalTruncation renaming (rec to p-rec)

open import Cubical.Relation.Nullary

open import Operad.Fin
open import Operad.FinSet.Base
open import Operad.FinSet.Function
open import Operad.FinSet.Product.Base
open import Operad.FinSet.Properties

private
  variable
    ℓ₁ ℓ₂ ℓ₃ ℓ₄ : Level
    W : Type ℓ₁
    X : Type ℓ₂
    Y : Type ℓ₃
    Z : Type ℓ₄

  open Iso

  invIsEquiv : (I : Iso X Y) → isEquiv (inv I)
  invIsEquiv I = composesToId→Equiv (fun I) (inv I) (funExt (rightInv I)) (isoToIsEquiv I)

  isEquivExpand : {f : X → Y} (I₁ : Iso X W) (I₂ : Iso Y Z) →
                  isEquiv f → isEquiv (fun I₂ ∘ f ∘ inv I₁)
  isEquivExpand {f = f} I₁ I₂ eqv =
    snd (compEquiv (inv I₁ , invIsEquiv I₁) (compEquiv (f , eqv) (fun I₂ , isoToIsEquiv I₂)))

  isEquivCollapse : {f : X → Y} (I₁ : Iso X W) (I₂ : Iso Y Z) →
                    isEquiv (fun I₂ ∘ f ∘ inv I₁) → isEquiv f
  isEquivCollapse {f = f} I₁ I₂ eqv =
   let eqv′ = snd (compEquiv (fun I₁ , isoToIsEquiv I₁)
                             (compEquiv (fun I₂ ∘ f ∘ inv I₁ , eqv) (inv I₂ , invIsEquiv I₂)))
    in subst isEquiv (funExt λ x → leftInv I₂ _ ∙ cong f (leftInv I₁ x)) eqv′

isFiniteIsEquiv : isFinite X → isFinite Y → (f : X → Y) → isFinite (isEquiv f)
isFiniteIsEquiv  (m , p′) (n , q′) f =
  p-rec isPropIsFinite (λ p →
    p-rec isPropIsFinite (λ q →
      decRec (λ r  → isFiniteContr (isEquivCollapse p q r , isPropIsEquiv f _))
             (λ ¬r → isFiniteEmpty (⊥-rec ∘ ¬r ∘ isEquivExpand p q))
             (isFinEquiv (fun q ∘ f ∘ inv p))
    ) q′
  ) p′

isFiniteIsEmbedding : isFinite X → isFinite Y → (f : X → Y) → isFinite (isEmbedding f)
isFiniteIsEmbedding (_ , p′) (_ , q′) f =
  p-rec isPropIsFinite (λ p →
    p-rec isPropIsFinite (λ q →
      decRec (λ r → isFiniteContr ({!!} , isEmbeddingIsProp {!!}))
             (λ ¬r → isFiniteEmpty (⊥-rec ∘ ¬r ∘ {!!}))
             (DecEmbedding discreteFin (fun q ∘ f ∘ inv p))
       -- DecEmbedding discreteFin (fun q ∘ f ∘ inv p)
    ) q′
  ) p′

isFinite≃ : isFinite X → isFinite Y → isFinite (X ≃ Y)
isFinite≃ A B = isFiniteΣ (isFiniteΠ A λ _ → B) λ _ → isFiniteIsEquiv A B _

isFiniteIso : isFinite X → isFinite Y → isFinite (Iso X Y)
isFiniteIso (m , p′) (n , q′) =
  p-rec isPropIsFinite (λ p →
    p-rec isPropIsFinite (λ q →
      {!!}
    ) q′
  ) p′

isFinite≃→≡ : isFinite (X ≃ Y) → isFinite (X ≡ Y)
isFinite≃→≡ (n , I) = n , p-rec propTruncIsProp (∣_∣ ∘ compIso univalenceIso) I

isFinite≃→Iso : isFinite (X ≃ Y) → isFinite (Iso X Y)
isFinite≃→Iso (n , I) = n , {!!}

isFinite≡ : isFinite X → isFinite Y → isFinite (X ≡ Y)
isFinite≡ A B = isFinite≃→≡ (isFinite≃ A B)

_≃ⁿ_ : FinSet ℓ₁ → FinSet ℓ₂ → FinSet (ℓ-max ℓ₁ ℓ₂)
(_ , isFiniteA) ≃ⁿ (_ , isFiniteB) = _ , isFinite≃ isFiniteA isFiniteB

_≡ⁿ_ : FinSet ℓ₁ → FinSet ℓ₁ → FinSet (ℓ-suc ℓ₁)
(_ , isFiniteA) ≡ⁿ (_ , isFiniteB) = _ , isFinite≡ isFiniteA isFiniteB

Isoⁿ : FinSet ℓ₁ → FinSet ℓ₂ → FinSet (ℓ-max ℓ₁ ℓ₂)
Isoⁿ (A , isFiniteA) (B , isFiniteB) = Iso A B , {!!}
